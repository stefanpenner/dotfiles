let g:ackprg = 'ag --nogroup --nocolor --column'

nnoremap <leader><space> :noh<cr>
set t_Co=256
colorscheme solarized
colorscheme desert

let g:gitgutter_enabled = 0

if has("gui_running")
  set guioptions=egmrt
  set guioptions-=r
  set guioptions-=l
  au FocusLost * :wa
endif

let g:airline_theme='dark'

function! ToggleNuMode()
  if(&rnu == 1)
    set nu
  else
    set rnu
  endif
endfunction
nnoremap <leader>b :call ToggleNuMode()<CR>

function! StripWhitespace ()
    exec ':%s/ \+$//gc'
endfunction

map <leader>s :call StripWhitespace ()<CR>
map <leader>r :w \| ! ruby %

au BufReadPost * set relativenumber

au BufRead,BufNewFile *.coffee setfiletype javascript
au BufRead,BufNewFile *.handlebars setfiletype javascript
au BufRead,BufNewFile *.clj setfiletype lisp
au BufRead,BufNewFile Assetfile setfiletype ruby

set statusline=%f\ %m\ %r
" Save on Undo

set notimeout
set ttimeout
set timeoutlen=20
set clipboard=unnamed
" set winwidth=84
" " We have to have a winheight bigger than we want to set winminheight. But if
" " we set winheight to be huge before winminheight, the winminheight set will
" " fail.
" set winheight=50
" set winheight=999

if has("mouse")
  set mouse=a
endif

map <silent> <Leader>rt :!bundle list --paths \| xargs /usr/local/bin/ctags -R * <CR><CR>
let Tlist_Ctags_Cmd='/usr/local/bin/ctags'
let Tlist_WinWidth=50
map <leader>t :TlistOpen<cr>
let g:tagbar_type_javascript = {
    \ 'ctagsbin' : '/usr/local/bin/jsctags'
    \ }

" let g:tagbar_type_coffee = {
"       \ 'ctagsbin' : 'coffeetags',
"       \ 'ctagsargs' : '',
"       \ 'kinds' : [
"       \ 'f:functions',
"       \ 'o:object',
"       \ ],
"       \ 'sro' : ".",
"       \ 'kind2scope' : {
"       \ 'f' : 'object',
"       \ 'o' : 'object',
"       \ }
"       \ }

nnoremap <leader>4 Orequire 'pry';binding.pry<esc>
nnoremap <leader>5 Orequire 'ruby-debug';debugger<esc>
nnoremap <leader>6 <C-w>v<C-w>l:A<cr>
nnoremap <leader>7 Orequire 'ruby-prof';result = RubyProf.profile {}; printer = RubyProf::CallStackPrinter.new(result); printer.print(open('stack.html','w')) <esc>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" better CONTROL-P "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:path_to_matcher = "/usr/local/bin/matcher"

let g:ctrlp_user_command = {
  \ 'types': {
    \ 1: ['.git/', 'cd %s && git ls-files'],
    \ },
  \ 'fallback': 'find %s -type f'
  \ }

function! g:GoodMatch(items, str, limit, mmode, ispath, crfile, regex)
  " the Command-T matcher doesn't do regex. Return now if that was requested.
  if a:regex == 1
    let [lines, id] = [[], 0]
    for item in a:items
      let id += 1
      try | if !( a:ispath && item == a:crfile ) && (match(item, a:str) >= 0)
        cal add(lines, item)
      en | cat | brea | endt
    endfo
    return lines
  end

  " a:mmode is currently ignored. In the future, we should probably do
  " something about that. the matcher behaves like "full-line".
  let cmd = g:path_to_matcher . " --limit " . a:limit . " --manifest " . ctrlp#utils#cachefile() . " "
  if ! g:ctrlp_dotfiles
    let cmd = cmd . "--no-dotfiles "
  endif
  let cmd = cmd . a:str
  return split(system(cmd))

endfunction
let g:ctrlp_match_func = { 'match': 'g:GoodMatch' }

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" WITCH BETWEEN TEST AND PRODUCTION CODE
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! OpenTestAlternate()
  let new_file = AlternateForCurrentFile()
  exec ':e ' . new_file
endfunction
function! AlternateForCurrentFile()
  let current_file = expand("%")
  let new_file = current_file
  let in_spec = match(current_file, '^spec/') != -1
  let going_to_spec = !in_spec
  let in_app = match(current_file, '\<controllers\>') != -1 || match(current_file, '\<models\>') != -1 || match(current_file, '\<views\>') != -1
  if going_to_spec
    if in_app
      let new_file = substitute(new_file, '^app/', '', '')
    end
    let new_file = substitute(new_file, '\.rb$', '_spec.rb', '')
    let new_file = 'spec/' . new_file
  else
    let new_file = substitute(new_file, '_spec\.rb$', '.rb', '')
    let new_file = substitute(new_file, '^spec/', '', '')
    if in_app
      let new_file = 'app/' . new_file
    end
  endif
  return new_file
endfunction
nnoremap <leader>. :call OpenTestAlternate()<cr>


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" UNNING TESTS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <leader>T :call RunNearestTest()<cr>
map <leader>a :call RunTests('')<cr>
map <leader>c :w\|:!script/features<cr>
map <leader>w :w\|:!script/features --profile wip<cr>
map ,t :w\|:! echo "ruby &" > asdf\<cr>  

function! RunTestFile(...)
    if a:0
        let command_suffix = a:1
    else
        let command_suffix = ""
    endif

    " Run the tests for the previously-marked file.
    let in_test_file = match(expand("%"), '\(.feature\|_spec.rb\)$') != -1
    if in_test_file
        call SetTestFile()
    elseif !exists("t:grb_test_file")
        return
    end
    call RunTests(t:grb_test_file . command_suffix)
endfunction

function! RunNearestTest()
    let spec_line_number = line('.')
    call RunTestFile(":" . spec_line_number . " -b")
endfunction

function! SetTestFile()
    " Set the spec file that tests will be run for.
    let t:grb_test_file=@%
endfunction

function! RunTests(filename)
    " Write the file and run tests for the given filename
    if match(a:filename, '\.feature$') != -1
        exec ":!script/features " . a:filename
    else
        if filereadable("script/test")
            exec ":!script/test " . a:filename
        elseif filereadable("Gemfile")
            exec ":!bundle exec rspec --color --drb " . a:filename
        else
            exec ":!rspec --color --drb " . a:filename
        end
    end
endfunction
